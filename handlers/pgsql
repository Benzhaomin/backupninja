# -*- mode: sh; sh-basic-offset: 3; indent-tabs-mode: nil; -*-
#
# PostgreSQL handler script for backupninja
#

getconf backupdir /var/backups/postgres
getconf databases all
getconf compress yes
getconf vsname

localhost=`hostname`

# If vservers are enabled, check that $vsname exists, and decide if the
# handler should use it or if it should just operate on the host.
local usevserver=no
if [ $vservers_are_available = yes ]; then
   if ! vservers_exist "$vsname" ; then
      fatal "The vserver given in vsname ($vsname) does not exist."
   else
      info "using vserver '$vsname'"
      usevserver=yes
   fi
fi

# As needed, make sure that :
#   * the specified vserver is running
#   * the specified vserver or host has the needed executables
if [ $usevserver = yes ]; then
    info "examining vserver '$vsname'"
    vroot="$VROOTDIR/$vsname"
    # is it running ?
    running=`$VSERVERINFO $vsname RUNNING`
    if [ "$running" = "1" ]; then
	if [ "$databases" == "all" ]; then
	    [ -x "$vroot`$VSERVER $vsname exec which $PGSQLDUMPALL`" ] || \
		fatal "Can't find $PGSQLDUMPALL in vserver $vsname."
	else
	    [ -x "$vroot`$VSERVER $vsname exec which $PGSQLDUMP`" ] || \
		fatal "Can't find $PGSQLDUMP in vserver $vsname."
	fi
    else
	fatal "vserver $vsname is not running."
    fi
else
    if [ "$databases" == "all" ]; then
	[ -x "`which $PGSQLDUMPALL`" ] || \
	    fatal "Can't find $PGSQLDUMPALL."
    else
	[ -x "`which $PGSQLDUMP`" ] || \
	    fatal "Can't find $PGSQLDUMP."
    fi
fi

# create backup dir, the vroot variable will be empty if no vsname was specified
# and will proceed to operate on the host
[ -d $vroot$backupdir ] || (debug "mkdir -p $vroot$backupdir"; mkdir -p $vroot$backupdir)
[ -d $vroot$backupdir ] || fatal "Backup directory '$vroot$backupdir'"

# give backup dir the good uid and permissions
# (in respect to the vserver, if $usevserver = yes)
pguid=`getent passwd postgres | awk -F: '{print $3}'`
[ -n "$pguid" ] || \
    fatal "No user called postgres`[ $usevserver = no ] || echo \" on vserver $vsname\"`."
debug "chown $pguid $vroot$backupdir"
chown $pguid $vroot$backupdir
debug "chmod 700 $vroot$backupdir"
chmod 700 $vroot$backupdir

# if $databases = all, use pg_dumpall
if [ "$databases" == "all" ]; then
    if [ $usevserver = yes ]; then
	execstr="$VSERVER $vsname exec su - postgres -c $PGSQLDUMPALL > $backupdir/${vsname}.sql"
    else
	execstr="su - postgres -c $PGSQLDUMPALL > $backupdir/${localhost}-all.sql"
    fi
    debug "$execstr"
    if [ ! $test ]; then
       output=`$execstr 2>&1`
       code=$?
	if [ "$code" == "0" ]; then
	    debug $output
	    info "Successfully finished dump of pgsql cluster"
	else
	    warning $output
	    warning "Failed to dump pgsql cluster"
	fi
    fi
    
# else use pg_dump on each specified database
else
    for db in $databases; do
	if [ $usevserver = yes ]
	    then
	    execstr="$VSERVER $vsname exec su - postgres -c $PGSQLDUMP $db > $backupdir/${db}.sql"
	else
	    execstr="su - postgres -c $PGSQLDUMP $db > $backupdir/${db}.sql"
	fi
	debug "$execstr"
	if [ ! $test ]; then
	    output=`$execstr 2>&1`
	    code=$?
	    if [ "$code" == "0" ]; then
		debug $output
		info "Successfully finished dump of pgsql database ${db}"
	    else
		warning $output
		warning "Failed to dump pgsql database ${db}"
	    fi
	fi
    done
fi

if [ "$compress" == "yes" ]; then
    output=`$GZIP -f $vroot$backupdir/*.sql 2>&1`
    debug $output
fi

return 0

